\documentclass[11pt, oneside, a4paper]{article}
\usepackage{enumitem}
\setlist{noitemsep}

\begin{document}

\title{Zusammenfassung: Pragmatic Programmer}
\author{Group Assignment SEP2\\Luzia Kündig}
\maketitle
% \newpage

\tableofcontents
% \newpage

\section{Intro}
Aus dem Vorwort:\\
Das Buch "Pragmatic Programmer" fokussiert sich neben verschiedenen technischen Best Practices vor allem auf auch den sogenannten "Common Sense", also den gesunden Menschenverstand. Es fokussiert sich auf Themen, die jeden Programmierer beschäftigen, wie z.B.  
\begin{itemize}[itemsep=4pt]
    \item die Zukunft mit heutigen Entscheidungen "schmerzfreier" gestalten 
    \item Dinge für seine Teammitglieder einfacher gestalten 
    \item Fehler zu machen und damit umzugehen 
    \item positive Gewohnheiten zu entwickeln 
    \item sein Toolset als Programmierer zu verstehen und zu beherrschen 
\end{itemize}

Saron Yitbarek, der das Vorwort schreibt, vergleicht den Nutzen dieses Buches für Programmier-Einsteiger mit den "freundlichen Nachbarn", die dir in einer fremden Stadt Dinge zeigen, die wichtig sind: die effizientesten Pendlerstrecken, die besten Cafés, Kniffe und Tricks die man kennen sollte. Dieser Vergleich trifft für mich absolut ins Schwarze.  

Da dieses Buch in 9 Kapiteln insgesamt 53 "Topics" quer durch den Alltag als Programmierer präsentiert, stellt es sich als eher schwierig heraus, dies alles in eine Zusammenfassung zu pressen. Hiermit möchte ich versuchen, die für mich hilfreichsten, interessantesten oder einfach amüsantesten Themen hervorzuheben. 
\section{Die Philosophie}
Die Grundeigenschaften eines Pragmatic Programmers, beschrieben unter dem Abschnitt \emph{Pragmatic Philosophy}. 
\begin{itemize}[itemsep=4pt]
    \item \emph{Think about your work}: If this sounds like hard work, then you're exhibiting the realistic characteristic. 
    \item \emph{Care about your craft}: We who cut mere stones must always envision cathedrals. 
    \item \emph{Kaizen (japanisch)}: Das Konzept, jeden Tag ganz kleine Verbesserungen vorzunehmen, um schlussendlich durchgehend hohe Qualität zu erreichen. 
    \item \emph{Take responsibility}: It's your life.
\end{itemize}

\subsection{Software Entropie}
Entropie in Software wird als \emph{Amount of Disorder} oder \emph{Software Rot} beschrieben. 
Software altert. Um die gegebene Qualität über eine längere Zeit zu erhalten, sollten Probleme 
(sog. \emph{Broken Windows}) wie zum Beispiel
\begin{itemize}[itemsep=4pt]
    \item schlechtes Design
    \item falsche Entscheidungen
    \item unschöner Code
\end{itemize}
möglichst bald behoben werden. So kann dazu beigetragen werden, dass auch zukünftige Arbeiten
am Code auf gewissenhafte und saubere Weise ausgeführt werden.

\subsection{Veränderung}

Veränderung und der richtige Umgang damit ist das zweite grundlegende Konzept in diesem Buch. Passiert diese langsam und in kleinen Schritten, 
wird sie viel weniger wahrgenommen als wenn auf einen Schlag etwas komplett anders ist.
Im positiven kann man sich dies zu Nutze machen, indem man Verbesserungen in kleinen Schritten einführt und den Menschen Zeit gibt.

Kleine, stetige Veränderungen in der Aussenwelt oder den Voraussetzungen in einem Projekt sind aber ebenso 
einfach zu verpassen, wie sie im positiven anzunehmen sind. Deshalb sollte man stets den Blick
vom aktuellen, spezifischen Problem auch wieder aufs grosse Ganze richten und hinterfragen, ob man immernoch 
auf dem richtigen Weg ist. 

\section{Wissen, Technologien, Beherrschen der Tools}
\subsection{Knowledge Portfolio}
Das beste und wichtigste Asset, das ein Programmierer in seinen Job mitbringt, ist Wissen. Unendlich viele verschiedene Technologien, die
sich extrem schnell verändern, machen es unumgänglich, dass man sich stetig weiterbildet, und wenn es nur einige Minuten am Tag oder in der Woche sind.
Neue Technologien ausprobieren, Kurse besuchen, News und Publikationen lesen sollte im Zeitplan einen fixen Platz haben und wird im 
Idealfall auch vom Arbeitgeber geschätzt und vergütet, da es vor allem auch diesem zu Gute kommt.

\subsection{Shell Games, Power Editing, Text Manipulation}

- version control\\
- debugging\\
- engineering daybook\\

\section{The Essence of Good Design: Entscheidungen treffen}

\subsection{ETC - Easier to change}
Ein System hat ein gutes Design, wenn es sich an die Menschen, die es nutzen, anpassen kann. 

\emph{Easier to change} ist deshalb das grundlegende Prinzip, auf dem fast alle weiteren Designprinzipien aufbauen. Es soll keine feste Vorgabe sein, sondern eine Hilfe.
Immer wenn eine Entscheidung zwischen Vorgehen A oder B getroffen werden muss, sollte man sich hieran orientieren.

Um diese Denkweise zu verinnerlichen kann man sich diese Frage bewusst immer wieder stellen. Beim Speichern einer Datei, beim Schreiben eines Tests oder beim Beheben eines Bugs. 
Ist der Code, den ich soeben geschrieben habe \emph{easy to change}?

\subsection{DRY - Don't repeat yourself}
\emph{Jedes Stück an Information braucht eine einzige, eindeutige und authoritative Repräsentation in einem System.}

Das Duplizieren von Informationen führt unweigerlich zu Inkonsistenz. Sei dies im Code, in Dokumentationen oder anderswo. 
Weitere, nicht ganz so offensichtliche Arten von Duplikation:
\subsubsection*{Duplikation der Repräsentation}
\emph{Interne/Externe APIs:}
Das Wissen über die ausgetauschten Daten bzw. deren Struktur muss grundsätzlich auf beiden Seiten der Kommunikation vorhanden sein. 
Abhilfe schaffen können hier Sprachen zur neutralen Spezifikation von APIs, die idealerweise zentral abgelegt werden und zur Erstellung von automatisierten Tests und Test-Clients verwendet werden können.
\\
\\
\emph{Datenquellen:}
Falls möglich sollten Objekte aus ihrer Dantenbankrepresentation automatisiert erstellt werden können. 
Andernfalls müssen Änderungen an der Struktur an verschiedenen Orten durchgeführt werden.

\subsubsection*{Duplikation zwischen Entwicklern}
Diese Art von Duplikation ist wahrscheinlich am schwierigsten zu entdecken und adressieren. 
Ein wichtiges Mittel hierzu ist die Kommunikation von Teams zu stärken, innerhalb sowie übergreifend.
Weiter muss es einfacher sein, bereits erstellte Funktionalität wiederzuverwenden, als sie neu zu implementieren.

\subsection{Orthogonalität}
Wenn in der Geometrie zwei Vektoren orthogonal zueinander stehen, sind sie voneinander komplett unabhängig.

In der Softwareentwicklung wurde diese Idee als wichtiges Grundprinzip übernommen: Wenn an einem Element eine Änderung vorgenommen wird, sollen davon möglichst wenige oder keine anderen Elemente beeinflusst werden. 
Code soll möglichst modular aufgebaut sein, aufgeteilt in kleine Einheiten die klar definierte Funktionalität bieten.

Erreichen können wir dies mittels verschiedenen Grundsätzen.\\
\emph{Decoupling:} Wenige Abhängigkeiten bilden zwischen verschiedenen Modulen, resultiert meist in \emph{high cohesion}, was einen guten Zusammenhalt innerhalb eines Moduls beschreibt.
\\
\emph{Globale Daten vermeiden:} Globale Daten verbinden alle Module miteinander, die darauf zugreifen. Abhängigkeiten entstehen, Testing wird schwieriger, der Code wird schwieriger verständlich.
\\
\emph{Unit Tests als Gradmesser:} Wenn für einzelne Unit Tests verschiedenste Elemente aus dem Code eingebunden werden müssen, ist das ein schlechtes Zeichen. 


\subsection{Good Enough}
Die Qualität eines Produktes hängt von vielen Faktoren ab. Kosten, Zeit und Umfang eines Projektes spielen eine Rolle.
Am wichtigsten ist es dabei, diese Faktoren auszubalancieren, sodass die Qualität \emph{für den vorgesehenen Zweck} ausreichend ist und den Endbenutzer zufriedenstellt.
Sind die Kosten am Schluss viel höher oder der Umfang viel kleiner als erwartet, ist bessere Qualität der erbrachten Leistung meist keine Rechtfertigung. \\
\emph{Know when to stop.}

\subsection{Reversibility}
\emph{Es gibt keine finalen Entscheidungen.}


\subsection{More..}
- Naming\\
- don't trust anyone (not even yourself)\\
- programming by coincidence\\
- listen to your lizard brain\\
- Algorithm Speeds\\


\section{Code}
Wenn es um effektive Techniken geht, wie \emph{pragmatische Projekte} umgesetzt werden können, werden folgende Punkte diskutiert.
\subsection{Tracer Bullets}
Leuchtende Projektile sollen im Militär anzeigen, ob man die Zielscheibe auch wirklich trifft oder nicht. 
Genauso können beim Entwickeln kleine Einheiten von Funktionalität verwendet werden, um die End-zu-End Kommunikation quer durch alle Layers einer Architektur zu testen und zu garantieren.
Sollte das Ziel verfehlt werden, können Anpassungen in der Strategie oder im Toolset umgehend vorgenommen werden.

\subsection{Prototypes}
Prototypen sind lauffähige Systeme, die gebaut werden um bestimmte Aspekte eines Projektes auszuloten, neue Technologien zu testen oder Risiken zu minimieren.
Punkte wie Korrektheit, Komplettheit, Robustheit und Coding-Stil können vernachlässigt werden, da ein Prototyp nicht dazu da ist, später in der Produktion verwendet zu werden. 

\subsection{Domain Languages}
\textbf{>> todo <<}\\
\emph{Interne:} \\
\emph{Externe:} (Bsp. Ansible) Muss von einer Software / einem Tool  werden. \\

\subsection{Methodik: You can't write perfect Software}
- Design by Contract\\
- semantic invariants\\
- crash early\\
- outrunning your headlights\\
- resource balancing\\
- testing\\
- refactoring\\

\subsection{Bend or Break}
- test\\
- test\\

\subsection{Concurrency}
- Temporal Coupling: Zeitliche Abhängigkeit
- Shared State equals Incorrect State\\
- actors and processes\\
- blackboards\\

\section{Kommunizieren}
Kommunikation als Programmierer kann sein wie man sich im Code ausdrückt (Prinzipien wie DRY, ETC, ..), dasselbe gilt aber auch für die sprachliche Kommunikation.
Meetings mit Kunden, Kollegen und Vorgesetzten machen einen wichtigen Teil der Tätigkeit aus und entscheiden meist über Erfolg oder Misserfolg eines Projekts.
Deshalb sollten auch hier die eigenen Fähigkeiten gepflegt und gestärkt werden.

\begin{itemize}[itemsep=4pt]
    \item Kenne dein Publikum
    \item Wisse, was du hinüberbringen willst
    \item Wähle den richtigen Moment
    \item Wähle eine passende Ausdrucksart
    \item Beziehe dein Publikum mit ein
    \item Höre zu
    \item Bleibe keine Antworten schuldig
    \item Bringe Optionen statt Ausreden
    \item \textbf{Ja sagen}, wenn man sich sicher ist, dass etwas in der gewünschten Zeit oder auf die gewünschte Weise umsetzbar ist. 
    \item \textbf{Nein sagen}, wenn eine Deadline nicht sicher einzuhalten ist, man mehr Zeit zum abklären oder einschätzen braucht oder auf Unterstützung angewiesen ist.
    \item \textbf{Dokumentation} dort platzieren, wo sie gelesen wird. \\ Das \emph{wie} soll durch den Code selbsterklärend sein, das \emph{warum} kann als Kommentar eingefügt werden.\\Speziell bei APIs
\end{itemize}

\section{Projekte Planen, Schätzen, Erfahrungswerte}
- how accurate is accurate enough\\
- what to say when asked for an estimate\\
- the requirements pit

\section{Working in a (pragmatic) Team on (pragmatic) Projects}
- solving impossible puzzles\\
- working together\\
- pragmatic teams\\
- coconuts don't cut it - cargo cult\\

\section{\emph{agile thinking}}
Hinterfragen der Situation, der Entscheidungen und der Methoden


\end{document}